---
title: "JS and TS Tips"
emoji: "📚"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["javascript", "typescript"]
published: false
publication_name: "gmomedia"
---


## はじめに

:::message
修正や追加等はコメントまたはGitHubで編集リクエストをお待ちしております。
:::

## 概要

JSとTSのTipsをまとめます。
簡単なものから難しいものまでをまとめています。

## 分割代入(デストラクチャリング)

分割代入で、オブジェクトや配列の中身を取り出すと同時に変数に代入できます。

### 連想配列の場合

連想配列の場合は、キーを指定して取り出すことができます。
キーに別名をつけることもできます。

```js:destructuring.js
const obj = { a: 1, b: 2, c: 3 };
const { a, b, c: d } = obj; // cをdとして取り出す

console.log(a, b, d); // 1 2 3
```

:::details TypeScript

```ts:destructuring.ts
const obj = { a: 1, b: 2, c: 3 };
const { a, b, c: d } = obj; // cをdとして取り出す

console.log(a, b, d); // 1 2 3
```

:::

### 配列の場合

配列の場合は、順番に取り出すことができます。
必ずしも全ての要素を取り出す必要はありません。
`[a, b]` のように、取り出したい要素のみを指定することもできます。
また、`[a, ...b]` のように、`...` を使って残りの要素を取り出すこともできます。
`[, , c]` のように、取り出したい要素の前に `,` をつけることで、その要素をスキップすることもできます。

```js:destructuring.js
const arr = [1, 2, 3];

const [a, b] = arr; // 1, 2を取り出す
const [, , c] = arr; // 3を取り出す
const [, ...d] = arr; // 1以外を取り出す

console.log(a, b, c, d); // 1 2 3 [2, 3]
```

:::details TypeScript

```ts:destructuring.ts
const arr = [1, 2, 3];

const [a, b] = arr; // 1, 2を取り出す
const [, , c] = arr; // 3を取り出す
const [, ...d] = arr; // 1以外を取り出す

console.log(a, b, c, d); // 1 2 3 [2, 3]
```

## 浅いコピーと深いコピー

浅いコピーと深いコピーはC言語をやったことがある人なら、馴染みのある言葉だと思います。

### 浅いコピー

浅いコピーは、オブジェクトの参照をコピーします。
変数はよく箱と例えられますが、参照は箱がある場所を指していると考えるとわかりやすいと思います。

```js:shallowCopy.js
const obj = { a: 1, b: 2 };
const shallowCopy = obj;

shallowCopy.a = 2;

console.log(obj); // { a: 2, b: 2 }
```

:::details TypeScript

```ts:shallowCopy.ts
const obj = { a: 1, b: 2 };
const shallowCopy = obj;

shallowCopy.a = 2;

console.log(obj); // { a: 2, b: 2 }
```

:::

箱の場所をコピーしているため、`shallowCopy` を変更すると、`obj` も変更されます。
場所しか知らないので、同じ箱に書き込んでしまったと考えるとわかりやすいと思います。

### 深いコピー

深いコピーは、オブジェクトの値をコピーします。
箱自体を増やすと考えるとわかりやすいと思います。

```js:deepCopy.js
const obj = { a: 1, b: 2 };
const deepCopy = { ...obj };

deepCopy.a = 2;

console.log(obj); // { a: 1, b: 2 }
```

:::details TypeScript

```ts:deepCopy.ts
const obj = { a: 1, b: 2 };
const deepCopy = { ...obj }; // or Object.assign({}, obj)

deepCopy.a = 2;

console.log(obj); // { a: 1, b: 2 }
```

:::

`{...obj}` の　`...` は、スプレッド構文と呼ばれ、配列やオブジェクトを展開することができます。
`Object.assign` を使っても同じことができますが、分割代入の方が簡潔に書けるので、こちらを使うことをおすすめします。

## 有理数であるか判定する

有理数かどうかを判定するときに、以下のようなコードでは不具合が発生します。

```js:isNumber.js
const isNumber = (num) => {
  if (isFinite(num)) {
    console.log("num is truthy");
  } else {
    console.log("num is falsy");
  }
};

isNumber(NaN); // num is falsy
isNumber(Infinity); // num is falsy
isNumber(null); // id is truthy
isNumber("1"); // id is truthy
```

:::details TypeScript

```ts:isNumber.ts
const isNumber = (num: unkown) => {
  if (isFinite(num as number)) {
    console.log("num is truthy");
  } else {
    console.log("num is falsy");
  }
};

isNumber(NaN); // num is falsy
isNumber(Infinity); // num is falsy
isNumber(null); // id is truthy
isNumber("1"); // id is truthy
```

:::

これは、jsの仕様で、`isFinite` は `Infinity` or `NaN` or `undefined` or 連想配列(`{}`) の場合に `false` を返します。
それ以外の場合は、`true` を返します。
このような場合は、以下のように判定する必要があります。

```js:isNumber.js
const isNumber = (num) => {
  if (Number.isFinite(num)) {
    console.log("num is truthy");
  } else {
    console.log("num is falsy");
  }
};
```

:::details TypeScript

```ts:isNumber.ts
const isNumber = (num: unknown) => {
  if (Number.isFinite(num)) {
    console.log("num is truthy");
  } else {
    console.log("num is falsy");
  }
};
```

:::

`Number.isFinite` は、`isFinite` と異なり、数値型に対してのみ `true` を返します。
`Infinity` or `NaN` は `false` を返します。

### typeofではダメなのか

`typeof` でも判定できそうですが、以下のような落とし穴があります。

```js:isNumber.js
const isNumber = (num) => {
  if (typeof num === "number") {
    console.log("num is truthy");
  } else {
    console.log("num is falsy");
  }
};

isNumber(NaN); // num is truthy
isNumber(Infinity); // num is truthy
isNumber(null); // num is falsy
isNumber("1"); // num is falsy
```

:::details TypeScript

```ts:isNumber.ts
const isNumber = (num: unknown) => {
  if (typeof num === "number") {
    console.log("num is truthy");
  } else {
    console.log("num is falsy");
  }
};

isNumber(NaN); // num is truthy
isNumber(Infinity); // num is truthy
isNumber(null); // num is falsy
isNumber("1"); // num is falsy
```

:::

`Infinity` と `NaN` は `number` 型であるため、`true` を返します。
そのため、有理数かどうかを判定する場合は、`Number.isFinite` を使う必要があります。

## 配列を判定する

配列は`typeof` で`object` と判定されます。
一見すると、判定できそうです。
ですが、`typeof` には以下のような落とし穴があります。

```js:isArray.js
const isArray = (arr) => {
  if (typeof arr === "object") {
    console.log("arr is truthy");
  } else {
    console.log("arr is falsy");
  }
};

isArray([]); // arr is truthy
isArray({}); // arr is truthy
isArray(null); // arr is truthy
```

:::details TypeScript

```ts:isArray.ts
const isArray = (arr: unknown) => {
  if (typeof arr === "object") {
    console.log("arr is truthy");
  } else {
    console.log("arr is falsy");
  }
};

isArray([]); // arr is truthy
isArray({}); // arr is truthy
isArray(null); // arr is truthy
```

:::

この関数に `null` or 連想配列(`{}`) を渡すと、`true` となります。
これは、`null` と　連想配列(`{}`) が `object` であるためです。

このような場合は、以下のように判定する必要があります。

```js:isArray.js
const isArray = (arr) => {
  if (Array.isArray(arr)) {
    console.log("arr is truthy");
  } else {
    console.log("arr is falsy");
  }
};
```

:::details TypeScript

```ts:isArray.ts
const isArray = (arr: unknown) => {
  if (Array.isArray(arr)) {
    console.log("arr is truthy");
  } else {
    console.log("arr is falsy");
  }
};
```

:::

`Array.isArray` は、`typeof` と異なり、`null` や 連想配列(`{}`)を `false` として判定します。

## デフォルト引数の仕様

### デフォルト引数は、関数が呼び出された時に評価される

デフォルト引数は、関数が呼び出された時に評価されます。
言い換えるなら毎回初期化されるということです。

```js:defaultArgs.js
const defaultArgs = (value, arr = []) => {
  arr.push(value);
  console.log(arr);
};

defaultArgs(1); // [1]
defaultArgs(2); // [2]
```

:::details TypeScript

```ts:defaultArgs.ts
const defaultArgs = (value: number, arr: number[] = []) => {
  arr.push(value);
  console.log(arr);
};

defaultArgs(1); // [1]
defaultArgs(2); // [2]
```

:::

### 前の引数を後のデフォルト引数で使える

前の引数を使ってデフォルト引数を設定できます。

```js:defaultArgs.js
const defaultArgs = (a, b = a) => {
  console.log(a, b);
};

defaultArgs(1); // 1 1
defaultArgs(1, 2); // 1 2
```

:::details TypeScript

```ts:defaultArgs.ts
const defaultArgs = (a: number, b: number = a) => {
  console.log(a, b);
};

defaultArgs(1); // 1 1
defaultArgs(1, 2); // 1 2
```

:::
