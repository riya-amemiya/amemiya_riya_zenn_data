---
title: "V8エンジンの最適化戦略"
emoji: "🏎️"
type: "tech" # tech: 技術記事 / idea: アイデア
topics: ["v8", "javascript", "compiler"]
published: true
publication_name: "gmomedia"
---

## はじめに

:::message
修正や追加等はコメントまたはGitHubで編集リクエストをお待ちしております。
:::

V8エンジンは、JavaScriptの実行性能を最大化するために3つの特殊化されたコンパイラを戦略的に使い分けています。

- **Sparkplug**：高速な非最適化コンパイラ
- **Maglev**：中間層の最適化コンパイラ
- **TurboFan**：高度な最適化コンパイラ

これらが実行頻度に応じて段階的に適用されることで、最適なパフォーマンスを実現しています。

## Sparkplug：常識を覆した高速コンパイラ

V8 v9.1で導入されたSparkplugは、従来のコンパイラ設計の常識を完全に無視することで、驚異的な高速コンパイルを実現しました。

### 核心的な実装

通常のコンパイラは、ソースコード → AST → 中間表現 → 最適化 → 機械語という段階を踏みます。しかしSparkplugはこれらを全て省略し、バイトコードから直接機械語を生成します。実装の中核は、コンパイラ全体が実質的に巨大なswitch文を含む単一のループとして構成されている点です。各バイトコード命令に対して、事前に用意された固定のマシンコード生成関数を呼び出すだけという、極めてシンプルな構造です。

### 効果的なシナリオ

この一見乱暴なアプローチが効果的である理由は、JavaScriptの実行パターンにあります。

- 多くのコードは数回しか実行されない
- 複雑な最適化にかける時間が実行時間を上回ることが多い
- 短命なスクリプトや小さな関数には即座の高速化が重要

Sparkplugはこの事実を受け入れ、マシン語への変換による速度向上以外の最適化を行わないことで、コンパイル時間を大幅に削減しています。

### インタープリタ互換性の重要性

特に重要なのは、Sparkplugがインタープリタ互換のスタックフレームを維持する点です。これにより以下のメリットが得られます：

- Ignitionインタープリタとの間でオンスタック置換（OSR）が効率的に行える
- 実行中のコードを動的に切り替える際のオーバーヘッドが最小限になる
- デバッガやプロファイラなど既存ツールとの互換性が保たれる

## Maglev：バランス型の最適化コンパイラ

SparkplugとTurboFanの間を埋めるMaglevは、「十分に良いコードを、十分に速く」という明確な設計思想を持っています。

### 主要な技術要素

- **SSA（静的単一代入）形式**：データフロー解析を効率的に行える
- **制御フローグラフ（CFG）**：ループや条件分岐の最適化が可能
- **型フィードバックの活用**：Ignitionが収集した型情報を基に最適化
- **インライン展開**：小さな関数の呼び出しオーバーヘッドを削減

### SSA形式の採用

MaglevはSSA（静的単一代入）形式を採用しています。この形式では各変数が一度だけ代入されるため、データフロー解析が劇的に簡単になります。定数伝播や不要コード削除といった基本的な最適化が、複雑な解析なしに実現できるのです。

### 制御フローグラフの活用

制御フローグラフ（CFG）を構築することで、ループ不変式の移動やコードモーションが可能になります。ただし、TurboFanのような徹底的な最適化は行いません。例えばループ融合やベクトル化といった高度な変換は省略し、コンパイル時間を抑えています。

### 型フィードバックによる最適化

Ignitionが収集した型情報の活用も重要です。特定のプロパティアクセスパターンに対して、オブジェクトの形状（hidden class）をチェックし、既知のオフセットから直接値を読み取るコードを生成します。この型特化により、動的型付け言語であるJavaScriptでも、静的型付け言語に近い性能を実現できます。

### インライン展開の戦略

インライン展開も慎重に適用されます。小さな関数は積極的にインライン化しますが、コード肥大化を防ぐため、閾値を超えるとインライン化を控えます。このバランス感覚がMaglevの実用性を支えています。

## TurboFan：最高峰の最適化コンパイラ

TurboFanは、V8の最も高度な最適化を担当するコンパイラです。

### 高度な最適化技術

- **Sea-of-Nodes IR**：データフローと制御フローを統一的に扱う中間表現
- **投機的最適化と脱最適化**：実行履歴に基づいて積極的に最適化
- **ループ最適化**：ループ不変式の移動、融合、ベクトル化など
- **グローバル値番号付け（GVN）**：冗長な計算を削除
- **強度低減**：除算を乗算に、乗算をシフト演算に置き換えるなど

### Sea-of-Nodes IRの活用

Sea-of-Nodes IRという独自の中間表現を採用しており、データフローと制御フローを統一的に扱います。この表現により、命令の順序付けが柔軟になり、より積極的な最適化が可能になります。従来の基本ブロック単位の最適化を超えて、グラフ全体を俯瞰した大域的な最適化を実現しています。

### 投機的最適化

投機的最適化はTurboFanの真骨頂です。「この変数は常に数値」「この条件分岐は常にtrue」といった仮定を置いて最適化し、仮定が外れたら脱最適化（deoptimization）で元に戻します。この仕組みにより、動的型付け言語であるにもかかわらず、実行時の振る舞いに基づいた静的言語並みの最適化が可能になります。

### ループ最適化

ループに対しては特に徹底的な最適化を行います。ループ不変式の移動、ループ融合、ベクトル化、さらにはループの完全な除去まで試みます。数値計算が多いアプリケーションでは、これらの最適化により劇的に性能が向上します。

### GVNと強度低減

グローバル値番号付け（GVN）で冗長な計算を排除し、強度低減で高コストな演算を低コストな演算に置き換えます。除算を乗算に、乗算をシフト演算に変換するなどの最適化により、数値演算のボトルネックを解消します。

### TurboFanの適用タイミング

TurboFanのこれらの高度な最適化技術により、長時間実行される重要な関数に対して最高レベルの最適化が適用されます。ただし、その複雑さゆえに、コンパイル時間も他の層に比べて長くなります。そのため、V8は実行時の挙動を見極めながら、適切なタイミングでTurboFan最適化を適用します。

## 実践的な最適化のポイント

### 1. 関数の共通化による最適化促進

同じ処理を共通の関数として実装することで、V8の最適化対象になりやすくなります。インライン関数やアロー関数を毎回新しく定義するのではなく、共通の関数として切り出すことで、実行回数が増え、より高度な最適化の恩恵を受けられます。

### 2. 型の一貫性維持

変数の型を途中で変更しないことで、投機的最適化の効果を最大化できます。TypeScriptの型定義は実行時には影響しませんが、開発時に型の一貫性を保つ助けになります。なお、関数の引数の型が違っても、V8は4回までは最適化してくれます。

### 3. オブジェクト形状の保持

オブジェクトのプロパティは定義時に全て設定し、後から動的に追加しないようにします。プロパティの追加順序も一定に保つことで、hidden classの共有が促進され、プロパティアクセスが高速化されます。

## まとめ

V8の3層コンパイラ構造は、JavaScriptの動的な性質と高性能の要求を両立させる巧妙な仕組みです。開発者として意識すべきは、コードの構造を整理し、型の一貫性を保ち、V8が最適化しやすいパターンで実装することです。これらを意識することで、同じアルゴリズムでも大幅な性能向上が期待できます。
